\chapter{Implementation}
\section{Data Serialization}
As we decribed in the design section (\ref{sec:communication_design}) there are two main types of serialization that we needed:
\begin{itemize}
	\item json serialization for request-response interaction
	\item binary serialization for  data exhanged through websockets
\end{itemize}

For the first one we decided to use the \texttt{spray-json} library since it is the one recommended to be used with akka.

Regadring binary serialization we chose instead to use \texttt{java.io} serialization. This is because there were no strict performance constraints in the requirements and we preferred to favor user-side usability: indeed the user of the library is able to exchange messages between clients and server simply defining classes that extend the \texttt{java.io.Serializable} inetrface.



\section{Stefano Salvatori}
In the early stages of the project I have mainly worked on the server package. First I defined the \texttt{GameServer} trait providing a basic implementation of it with a \texttt{ServerActor} that allowed to run a server listening on specific host an port; then I started working on the \texttt{ServerRoom} class and the \texttt{RoomActor} so that it would be possible for clients to connect to a room and for developers to create their own type of room. Concerning ServerRoom class i've also implemented the automatic close functionality and the periodic state synchronization to clients.

Later on I worked on the communication protocol implementing all the classes in the \texttt{common.communication} package. Regarding communication between client and server i've also designed and implemented the websocket utilities in the \texttt{server.communication} package. Here i had to use some advanced features of akka reactive streams. 

During the third and fourth sprint of the project i developed the \textit{MoneyGrabber} game as an example of the main functionalities of the library. 

\section{Gabriele Guerrini}

\section{Riccardo Salvatori}

Initially I worked on the Route service component. I used a DSL provided by the akka-http library to easily define and handle specific routes used by the library. Then I defined the \textit{RoomHandler} component that is in fact used by the RouteService to .
I worked on the client side api defining the client  room trait \textit{ClientRoom} with the implementations \textit{JoinableRoom} and \textit{JoinedRoom}. Therefore I worked on functionality to join, reconnect and leave rooms.
Furthermore I worked on the implementation of the \textit{matchmaking} functionality client side: \textit{ClientMatchmaker} and \textit{ClientMatchmakerActor}.

I implemented the \textit{RockPaperScissor} example using scalafx and prolog.

In the client side developing I was able to make an extensive use of reactive and asynchronus programming by the use of actors, futures and reactive streams. 
I could appreciate the use of \textit{for comprehension} syntax provided by scala to combine a work with futures. 
I was also  to improve my knowledge of  Akka library and actor programming; also combined with a functional approach.














